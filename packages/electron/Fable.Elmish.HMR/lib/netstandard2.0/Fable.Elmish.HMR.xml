<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Fable.Elmish.HMR</name></assembly>
<members>
<member name="M:HMR.Webpack.IHot.status">
<summary>
 **Description**
 Retrieve the current status of the hot module replacement process.
 **Parameters**


 **Output Type**
   * `Status`

 **Exceptions**

</summary>
</member>
<member name="M:HMR.Webpack.IHot.removeStatusHandler(Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit})">
<summary>
 **Description**
 Remove a registered status handler.
 **Parameters**
   * `callback` - parameter of type `obj -&gt; unit`

 **Output Type**
   * `unit`

 **Exceptions**

</summary>
</member>
<member name="M:HMR.Webpack.IHot.removeDisposeHandler(Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit})">
<summary>
 **Description**
 Remove the callback added via `dispose` or `addDisposeHandler`.
 **Parameters**
   * `callback` - parameter of type `obj -&gt; unit`

 **Output Type**
   * `unit`

 **Exceptions**

</summary>
</member>
<member name="P:HMR.Webpack.IHot.data">
<summary>
 Optional data coming from disposed module
</summary>
</member>
<member name="M:HMR.Webpack.IHot.dispose(System.Object)">
<summary>
 **Description**
 Add a handler which is executed when the current module code is replaced.
 This should be used to remove any persistent resource you have claimed or created.
 If you want to transfer state to the updated module, add it to given `data` parameter.
 This object will be available at `module.hot.data` after the update.
 **Parameters**
   * `data` - parameter of type `obj`

 **Output Type**
   * `unit`

 **Exceptions**

</summary>
</member>
<member name="M:HMR.Webpack.IHot.decline">
<summary>
 **Description**
 Reject updates for itself.
 **Parameters**


 **Output Type**
   * `unit`

 **Exceptions**

</summary>
</member>
<member name="M:HMR.Webpack.IHot.decline(Fable.Core.U2{Microsoft.FSharp.Collections.FSharpList{System.String},System.String})">
<summary>
 **Description**
 Reject updates for the given dependencies forcing the update to fail with a &apos;decline&apos; code.
 **Parameters**
   * `dependencies` - parameter of type `U2&lt;string list,string&gt;` - Either a string or an array of strings

 **Output Type**
   * `unit`

 **Exceptions**

</summary>
</member>
<member name="M:HMR.Webpack.IHot.check(Fable.Core.U2{System.Boolean,HMR.Webpack.ApplyOptions})">
<summary>
 **Description**
 Test all loaded modules for updates and, if updates exist, `apply` them.
 **Parameters**
   * `autoApply` - parameter of type `U2&lt;bool,ApplyOptions&gt;`

 **Output Type**
   * `JS.Promise&lt;obj&gt;`

 **Exceptions**

</summary>
</member>
<member name="M:HMR.Webpack.IHot.apply(HMR.Webpack.ApplyOptions)">
<summary>
 **Description**
 Continue the update process (as long as `module.hot.status() === &apos;ready&apos;`).
 **Parameters**
   * `options` - parameter of type `U2&lt;bool,ApplyOptions&gt;`

 **Output Type**
   * `JS.Promise&lt;obj&gt;`

 **Exceptions**

</summary>
</member>
<member name="M:HMR.Webpack.IHot.addStatusHandler(Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit})">
<summary>
 **Description**
 Register a function to listen for changes in `status`.
 **Parameters**


 **Output Type**
   * `unit`

 **Exceptions**

</summary>
</member>
<member name="M:HMR.Webpack.IHot.addDisposeHandler(Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit})">
<summary>
 **Description**
 Add a handler which is executed when the current module code is replaced.
 This should be used to remove any persistent resource you have claimed or created.
 If you want to transfer state to the updated module, add it to given `data` parameter.
 This object will be available at `module.hot.data` after the update.
 **Parameters**
   * `handler` - parameter of type `obj -&gt; unit`

 **Output Type**
   * `unit`

 **Exceptions**

</summary>
</member>
<member name="M:HMR.Webpack.IHot.accept(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit}})">
<summary>
 **Description**
 Accept updates for itself.
 **Parameters**
   * `errorHandler` - parameter of type `(obj -&gt; unit) option` - Function to fire when the dependencies are updated

 **Output Type**
   * `unit`

 **Exceptions**

</summary>
</member>
<member name="M:HMR.Webpack.IHot.accept(Fable.Core.U2{Microsoft.FSharp.Collections.FSharpList{System.String},System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit}})">
<summary>
 **Description**
 Accept updates for the given dependencies and fire a callback to react to those updates.
 **Parameters**
   * `dependencies` - parameter of type `U2&lt;string list,string&gt;` - Either a string or an array of strings
   * `errorHandler` - parameter of type `(obj -&gt; unit) option` - Function to fire when the dependencies are updated
 **Output Type**
   * `unit`

 **Exceptions**

</summary>
</member>
<member name="P:HMR.Webpack.ApplyOptions.onUnaccepted(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit}})">
<summary>
 Notifier for unaccepted modules
</summary>
</member>
<member name="P:HMR.Webpack.ApplyOptions.onErrored(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit}})">
<summary>
 Notifier for errors
</summary>
</member>
<member name="P:HMR.Webpack.ApplyOptions.onDisposed(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit}})">
<summary>
 Notifier for disposed modules
</summary>
</member>
<member name="P:HMR.Webpack.ApplyOptions.onDeclined(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit}})">
<summary>
 Notifier for declined modules
</summary>
</member>
<member name="P:HMR.Webpack.ApplyOptions.onAccepted(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit}})">
<summary>
 Notifier for accepted modules
</summary>
</member>
<member name="P:HMR.Webpack.ApplyOptions.ignoreUnaccepted(Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Ignore changes made to unaccepted modules.
</summary>
</member>
<member name="P:HMR.Webpack.ApplyOptions.ignoreErrored(Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Ignore errors throw in accept handlers, error handlers and while reevaluating module.
</summary>
</member>
<member name="P:HMR.Webpack.ApplyOptions.ignoreDeclined(Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Ignore changes made to declined modules.
</summary>
</member>
<member name="P:HMR.Webpack.ApplyOptions.onUnaccepted">
<summary>
 Notifier for unaccepted modules
</summary>
</member>
<member name="P:HMR.Webpack.ApplyOptions.onErrored">
<summary>
 Notifier for errors
</summary>
</member>
<member name="P:HMR.Webpack.ApplyOptions.onDisposed">
<summary>
 Notifier for disposed modules
</summary>
</member>
<member name="P:HMR.Webpack.ApplyOptions.onDeclined">
<summary>
 Notifier for declined modules
</summary>
</member>
<member name="P:HMR.Webpack.ApplyOptions.onAccepted">
<summary>
 Notifier for accepted modules
</summary>
</member>
<member name="P:HMR.Webpack.ApplyOptions.ignoreUnaccepted">
<summary>
 Ignore changes made to unaccepted modules.
</summary>
</member>
<member name="P:HMR.Webpack.ApplyOptions.ignoreErrored">
<summary>
 Ignore errors throw in accept handlers, error handlers and while reevaluating module.
</summary>
</member>
<member name="P:HMR.Webpack.ApplyOptions.ignoreDeclined">
<summary>
 Ignore changes made to declined modules.
</summary>
</member>
<member name="T:HMR.Webpack.Status.Fail">
<summary>
 An update has thrown an exception and the system&apos;s state has been compromised
</summary>
</member>
<member name="T:HMR.Webpack.Status.Abort">
<summary>
 An update was aborted, but the system is still in it&apos;s previous state
</summary>
</member>
<member name="T:HMR.Webpack.Status.Apply">
<summary>
 The process is calling the accept handlers and re-executing self-accepted modules
</summary>
</member>
<member name="T:HMR.Webpack.Status.Dispose">
<summary>
 The process is calling the dispose handlers on the modules that will be replaced
</summary>
</member>
<member name="T:HMR.Webpack.Status.Ready">
<summary>
 The update is prepared and available
</summary>
</member>
<member name="T:HMR.Webpack.Status.Prepare">
<summary>
 The process is getting ready for the update (e.g. downloading the updated module)
</summary>
</member>
<member name="T:HMR.Webpack.Status.Check">
<summary>
 The process is checking for updates
</summary>
</member>
<member name="T:HMR.Webpack.Status.Idle">
<summary>
 The process is waiting for a call to check (see below)
</summary>
</member>
<member name="M:HMR.Vite.IHot.dispose(System.Object)">
<summary>
 Add a handler which is executed when the current module code is replaced.
 This should be used to remove any persistent resource you have claimed or created.
 If you want to transfer state to the updated module, add it to given `data` parameter.
 This object will be available at `module.hot.data` after the update.
</summary>
</member>
<member name="M:HMR.Vite.IHot.dispose(Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit})">
<summary>
 Add a handler which is executed when the current module code is replaced.
 This should be used to remove any persistent resource you have claimed or created.
 If you want to transfer state to the updated module, add it to given `data` parameter.
 This object will be available at `module.hot.data` after the update.
</summary>
</member>
<member name="M:HMR.Vite.IHot.accept(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit}})">
<summary>
 **Description**
 Accept updates for itself.
 **Parameters**
   * `errorHandler` - parameter of type `(obj -&gt; unit) option` - Function to fire when the dependencies are updated

 **Output Type**
   * `unit`

 **Exceptions**

</summary>
</member>
<member name="P:HMR.Vite.ApplyOptions.onUnaccepted(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit}})">
<summary>
 Notifier for unaccepted modules
</summary>
</member>
<member name="P:HMR.Vite.ApplyOptions.onErrored(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit}})">
<summary>
 Notifier for errors
</summary>
</member>
<member name="P:HMR.Vite.ApplyOptions.onDisposed(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit}})">
<summary>
 Notifier for disposed modules
</summary>
</member>
<member name="P:HMR.Vite.ApplyOptions.onDeclined(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit}})">
<summary>
 Notifier for declined modules
</summary>
</member>
<member name="P:HMR.Vite.ApplyOptions.onAccepted(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit}})">
<summary>
 Notifier for accepted modules
</summary>
</member>
<member name="P:HMR.Vite.ApplyOptions.ignoreUnaccepted(Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Ignore changes made to unaccepted modules.
</summary>
</member>
<member name="P:HMR.Vite.ApplyOptions.ignoreErrored(Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Ignore errors throw in accept handlers, error handlers and while reevaluating module.
</summary>
</member>
<member name="P:HMR.Vite.ApplyOptions.ignoreDeclined(Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Ignore changes made to declined modules.
</summary>
</member>
<member name="P:HMR.Vite.ApplyOptions.onUnaccepted">
<summary>
 Notifier for unaccepted modules
</summary>
</member>
<member name="P:HMR.Vite.ApplyOptions.onErrored">
<summary>
 Notifier for errors
</summary>
</member>
<member name="P:HMR.Vite.ApplyOptions.onDisposed">
<summary>
 Notifier for disposed modules
</summary>
</member>
<member name="P:HMR.Vite.ApplyOptions.onDeclined">
<summary>
 Notifier for declined modules
</summary>
</member>
<member name="P:HMR.Vite.ApplyOptions.onAccepted">
<summary>
 Notifier for accepted modules
</summary>
</member>
<member name="P:HMR.Vite.ApplyOptions.ignoreUnaccepted">
<summary>
 Ignore changes made to unaccepted modules.
</summary>
</member>
<member name="P:HMR.Vite.ApplyOptions.ignoreErrored">
<summary>
 Ignore errors throw in accept handlers, error handlers and while reevaluating module.
</summary>
</member>
<member name="P:HMR.Vite.ApplyOptions.ignoreDeclined">
<summary>
 Ignore changes made to declined modules.
</summary>
</member>
<member name="T:HMR.Vite.Status.Fail">
<summary>
 An update has thrown an exception and the system&apos;s state has been compromised
</summary>
</member>
<member name="T:HMR.Vite.Status.Abort">
<summary>
 An update was aborted, but the system is still in it&apos;s previous state
</summary>
</member>
<member name="T:HMR.Vite.Status.Apply">
<summary>
 The process is calling the accept handlers and re-executing self-accepted modules
</summary>
</member>
<member name="T:HMR.Vite.Status.Dispose">
<summary>
 The process is calling the dispose handlers on the modules that will be replaced
</summary>
</member>
<member name="T:HMR.Vite.Status.Ready">
<summary>
 The update is prepared and available
</summary>
</member>
<member name="T:HMR.Vite.Status.Prepare">
<summary>
 The process is getting ready for the update (e.g. downloading the updated module)
</summary>
</member>
<member name="T:HMR.Vite.Status.Check">
<summary>
 The process is checking for updates
</summary>
</member>
<member name="T:HMR.Vite.Status.Idle">
<summary>
 The process is waiting for a call to check (see below)
</summary>
</member>
<member name="P:HMR.Parcel.IHot.data">
<summary>
 Optional data coming from disposed module
</summary>
</member>
<member name="M:HMR.Parcel.IHot.dispose(System.Object)">
<summary>
 **Description**
 Add a handler which is executed when the current module code is replaced.
 This should be used to remove any persistent resource you have claimed or created.
 If you want to transfer state to the updated module, add it to given `data` parameter.
 This object will be available at `module.hot.data` after the update.
 **Parameters**
   * `data` - parameter of type `obj`

 **Output Type**
   * `unit`

 **Exceptions**

</summary>
</member>
<member name="M:HMR.Parcel.IHot.accept(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit}})">
<summary>
 **Description**
 Accept updates for itself.
 **Parameters**
   * `errorHandler` - parameter of type `(obj -&gt; unit) option` - Function to fire when the dependencies are updated

 **Output Type**
   * `unit`

 **Exceptions**

</summary>
</member>
<member name="M:Elmish.HMR.Common.lazyView3``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Fable.React.ReactElement}}})">
<summary>
 Avoid rendering the view unless the model has changed.
 view: function of three arguments to render the model using the dispatch
</summary>
</member>
<member name="M:Elmish.HMR.Common.lazyView2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit},Fable.React.ReactElement}})">
<summary>
 Avoid rendering the view unless the model has changed.
 view: function of two arguments to render the model using the dispatch
</summary>
</member>
<member name="M:Elmish.HMR.Common.lazyView``1(Microsoft.FSharp.Core.FSharpFunc{``0,Fable.React.ReactElement})">
<summary>
 Avoid rendering the view unless the model has changed.
 view: function of model to render the view
</summary>
</member>
<member name="M:Elmish.HMR.Common.lazyView3With``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Fable.React.ReactElement}}},``0,``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit})">
<summary>
 Avoid rendering the view unless the model has changed.
 equal: function to compare the previous and the new model (a tuple of two states)
 view: function to render the model using the dispatch
 state1: new state to render
 state2: new state to render
 dispatch: dispatch function
</summary>
</member>
<member name="M:Elmish.HMR.Common.lazyView2With``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit},Fable.React.ReactElement}},``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit})">
<summary>
 Avoid rendering the view unless the model has changed.
 equal: function to compare the previous and the new states
 view: function to render the model using the dispatch
 state: new state to render
 dispatch: dispatch function
</summary>
</member>
<member name="M:Elmish.HMR.Common.lazyViewWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{``0,Fable.React.ReactElement},``0)">
<summary>
 Avoid rendering the view unless the model has changed.
 equal: function to compare the previous and the new states
 view: function to render the model
 state: new state to render
</summary>
</member>
<member name="M:Elmish.HMR.Program.run``3(Elmish.Program{Microsoft.FSharp.Core.Unit,``0,``1,``2})">
<summary>
 Start the dispatch loop with `unit` for the init() function.
</summary>
</member>
<member name="M:Elmish.HMR.Program.runWith``4(``0,Elmish.Program{``0,``1,``2,``3})">
<summary>
 Start the dispatch loop with `&apos;arg` for the init() function.
</summary>
</member>
</members>
</doc>
