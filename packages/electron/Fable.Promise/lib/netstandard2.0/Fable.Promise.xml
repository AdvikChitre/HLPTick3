<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Fable.Promise</name></assembly>
<members>
<member name="T:Promise.PromiseBuilder">
 <summary>
 A builder to provide promise Computation Expression support.

 The CE is available via <c>promise { ... }</c>
 <example>
 <code lang="fsharp">
 let double (value : int) =
     promise {
         return value * 2
     }
 </code>
 </example>
 </summary>
</member>
<member name="M:Promise.mapResultError``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Fable.Core.JS.Promise{Microsoft.FSharp.Core.FSharpResult{``2,``0}})">
 <summary>
 Evaluates to <c>myPromise |> Promise.map (Result.map fn)</c>
 <example>
 <code lang="fsharp">
 Promise.reject -1
 |> Promise.result
 |> Promise.mapResultError (fun value ->
     $"%s{value} is not a valid value"
 )
 |> Promise.map (fun value ->
     // value = Error "-1 is not a valid value"
 )
 </code>
 </example>
 </summary>
 <param name="fn">A mapper function</param>
 <param name="a">The input promise</param>
 <typeparam name="'E1"></typeparam>
 <typeparam name="'E2"></typeparam>
 <typeparam name="'T"></typeparam>
 <returns>A promise returning the result of applying the mapper function to the input promise in case of error, otherwise the result of the input promise as it is</returns>
</member>
<member name="M:Promise.bindResult``3(Microsoft.FSharp.Core.FSharpFunc{``0,Fable.Core.JS.Promise{``1}},Fable.Core.JS.Promise{Microsoft.FSharp.Core.FSharpResult{``0,``2}})">
 <summary>
 Transform the success part of a result promise into another promise.
 <example>
 <code lang="fsharp">
 let multiplyBy2 (value : int) =
     Promise.create (fun resolve reject ->
         resolve (value * 2)
     )

 Promise.lift 42
 |> Promise.result
 |> Promise.bindResult (fun value ->
     multiplyBy2 value
 )
 |> Promise.map (fun value ->
     // value = Ok 84
 )
 </code>
 </example>
 </summary>
 <param name="fn">The binder function</param>
 <param name="a">The input promise</param>
 <typeparam name="'T1"></typeparam>
 <typeparam name="'T2"></typeparam>
 <typeparam name="'E"></typeparam>
 <returns>Returns a new promise applying to the binder function to it if the input promise succeed</returns>
</member>
<member name="M:Promise.mapResult``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Fable.Core.JS.Promise{Microsoft.FSharp.Core.FSharpResult{``0,``2}})">
 <summary>
 Evaluates to `myPromise |> Promise.map (Result.map fn)`
 <example>
 <code lang="fsharp">
 Promise.lift 42
 |> Promise.result
 |> Promise.mapResult (fun value ->
     value + 10
 )
 |> Promise.map (fun value ->
     // value = Ok 52
 )
 </code>
 </example>
 </summary>
 <param name="fn">The mapping function</param>
 <param name="a">The input promise</param>
 <typeparam name="'T1"></typeparam>
 <typeparam name="'T2"></typeparam>
 <typeparam name="'E"></typeparam>
 <returns>A promise returning the result of applying the mapping function to the input promise result</returns>
</member>
<member name="M:Promise.result``1(Fable.Core.JS.Promise{``0})">
 <summary>
 Map the <c>Promise</c> result into a <c>Result</c> type.
 <example>
 <code lang="fsharp">
 Promise.lift 42
 |> Promise.result
 |> Promise.map (fun value ->
     // value = Ok 42
 )

 // Fail example
 Promise.reject "Invalid value"
 |> Promise.result
 |> Promise.map (fun value ->
     // value = Error "Invalid value"
 )
 </code>
 </example>
 </summary>
 <param name="a">The input promise</param>
 <typeparam name="'T"></typeparam>
 <returns>A promise returning <c>Ok</c> if the input promise succeed, <c>Error</c> if the input promise failed</returns>
</member>
<member name="M:Promise.all``1(System.Collections.Generic.IEnumerable{Fable.Core.JS.Promise{``0}})">
 <summary>
 Takes a sequence of promises as an input, and returns a single <c>Promise</c> that resolves to an array of the results of the input promises.
 <example>
 <code lang="fsharp">
 let p1 =
     promise {
         do! Promise.sleep 100
         return 1
     }
 let p2 =
     promise {
         do! Promise.sleep 200
         return 2
     }
 let p3 =
     promise {
         do! Promise.sleep 300
         return 3
     }

 Promise.all [p1; p2; p3]
 |> Promise.map (fun res ->
     // res = [|1; 2; 3 |]
 )
 |> Promise.map ...
 </code>
 </example>

 Note: If you need to return mixed types you can use boxing and unboxing

 <example>
 <code lang="fsharp">
 let users =
     promise {
         let! users = fetchUsers ()
         return box users
     }
 let posts =
     promise {
         let! posts = fetchPosts ()
         return box posts
     }

 Promise.all [p1; p2]
 |> Promise.map (fun res ->
     let users = unbox&lt;User list&gt; res.[0]
     let posts = unbox&lt;Post list&gt; res.[1]
     // ...
 )
 </code>
 </example>
 </summary>
 <param name="pr">A list of promise to wait for</param>
 <typeparam name="'T"></typeparam>
 <returns>Return a new promise returning an array containing all the promise result</returns>
</member>
<member name="M:Promise.Parallel``1(System.Collections.Generic.IEnumerable{Fable.Core.JS.Promise{``0}})">
 <summary>
 Takes a sequence of promises as an input, and returns a single <c>Promise</c> that resolves to an array of the results of the input promises.
 <example>
 <code lang="fsharp">
 let p1 =
     promise {
         do! Promise.sleep 100
         return 1
     }
 let p2 =
     promise {
         do! Promise.sleep 200
         return 2
     }
 let p3 =
     promise {
         do! Promise.sleep 300
         return 3
     }

 Promise.Parallel [p1; p2; p3]
 |> Promise.map (fun res ->
     // res = [|1; 2; 3 |]
 )
 |> Promise.map ...
 </code>
 </example>
 </summary>
 <param name="pr">A list of promise to wait for</param>
 <typeparam name="'T"></typeparam>
 <returns>Return a new promise returning an array containing all the promise result</returns>
</member>
<member name="M:Promise.tryStart``1(Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.Unit},Fable.Core.JS.Promise{``0})">
 <summary>
 Same as <c>Promise.start</c> but forcing you to handle the rejected state.
 <example>
 <code lang="fsharp">
 myPromise
 |> Promise.tryStart
     (fun error ->
         // Do something on error
     )
 </code>
 </example>
 </summary>
 <param name="fail">Function to apply if the promise fail</param>
 <param name="pr">The input promise</param>
 <typeparam name="'T"></typeparam>
</member>
<member name="M:Promise.start``1(Fable.Core.JS.Promise{``0})">
 <summary>
 Start a promise.

 Fake starting a promise. It is faking it because promise are hot meaning they execute directly after their creation.

 <c>Promise.start</c> is equivalent to <c>promise |> ignore</c>

 <example>
 <code lang="fsharp">
 myPromise
 |> Promise.start
 </code>
 </example>
 </summary>
 <param name="pr">The input promise</param>
 <typeparam name="'T"></typeparam>
</member>
<member name="M:Promise.eitherEnd``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.Unit},Fable.Core.JS.Promise{``0})">
 <summary>
 Same as <c>Promise.either</c> but stopping the promise execution.
 <example>
 <code lang="fsharp">
 somePromise
 |> Promise.eitherEnd
     (fun x -> string x)
     (fun err -> Promise.lift err.Message)
 </code>
 </example>
 </summary>
 <param name="success">Binder function to call if the input promise succeeds</param>
 <param name="fail">Binder function to call if the input promise fail</param>
 <param name="pr">The input promise</param>
 <typeparam name="'T"></typeparam>
</member>
<member name="M:Promise.eitherBind``2(Microsoft.FSharp.Core.FSharpFunc{``0,Fable.Core.JS.Promise{``1}},Microsoft.FSharp.Core.FSharpFunc{System.Exception,Fable.Core.JS.Promise{``1}},Fable.Core.JS.Promise{``0})">
 <summary>
 A combination of <c>bind</c> and <c>catchBind</c>, this function applies the <c>success</c> continuation when the input promise resolves successfully, or <c>fail</c> continuation when the input promise fails.
 <example>
 <code lang="fsharp">
 somePromise
 |> Promise.eitherBind
     (fun x -> string x |> Promise.lift)
     (fun err -> Promise.lift err.Message)
 |> Promise.map ...
 </code>
 </example>
 </summary>
 <param name="success">Binder function to call if the input promise succeeds</param>
 <param name="fail">Binder function to call if the input promise fail</param>
 <param name="pr">The input promise</param>
 <typeparam name="'T1"></typeparam>
 <typeparam name="'T2"></typeparam>
 <returns>A new promise which is the result of calling <c>success</c> if <c>pr</c> succeedes, or of <c>fail</c> if <c>pr</c> failed</returns>
</member>
<member name="M:Promise.either``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},Fable.Core.JS.Promise{``0})">
 <summary>
 A combination of <c>map</c> and <c>catch</c>, this function applies the <c>success</c> continuation when the input promise resolves successfully, or <c>fail</c> continuation when the input promise fails.
 <example>
 <code lang="fsharp">
 somePromise
 |> Promise.either
     (fun x -> string x)
     (fun err -> Promise.lift err.Message)
 |> Promise.map ...
 </code>
 </example>
 </summary>
 <param name="success">Function to call if the input promise succeeds</param>
 <param name="fail">Function to call if the input promise fail</param>
 <param name="pr">The input promise</param>
 <typeparam name="'T1"></typeparam>
 <typeparam name="'T2"></typeparam>
 <returns>A new promise which is the result of calling <c>success</c> if <c>pr</c> succeedes, or of <c>fail</c> if <c>pr</c> failed</returns>
</member>
<member name="M:Promise.catchEnd``1(Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.Unit},Fable.Core.JS.Promise{``0})">
 <summary>
 Used to catch errors at the end of a promise chain.
 <example>
 <code lang="fsharp">
 Promise.create (fun resolve reject ->
     reject (System.Exception "User not found")
 )
 |> Promise.map (fun _ ->
     // ...
 )
 |> Promise.map (fun _ ->
     // ...
 )
 |> Promise.catchEnd (fun error ->
     // ...
 ) // Returns unit
 </code>
 </example>
 </summary>
 <param name="fail">Fuction to call if the input promise fail</param>
 <param name="pr">The input promise</param>
 <typeparam name="'T"></typeparam>
</member>
<member name="M:Promise.catchBind``1(Microsoft.FSharp.Core.FSharpFunc{System.Exception,Fable.Core.JS.Promise{``0}},Fable.Core.JS.Promise{``0})">
 <summary>
 Handle an errored promise allowing to call a promise.

 This version of <c>catch</c> expects a function returning <c>Promise&lt;'T&gt;</c> as opposed to just <c>'T</c>. If you need to return just 'T, use <c>catch</c>.
 <example>
 <code lang="fsharp">
 Promise.create (fun resolve reject ->
     reject (System.Exception "User not found")
 )
 |> Promise.catchBind (fun error ->
     // Recover from the error, here we call another promise and returns it's result
     logErrorToTheServer error
 )
 |> Promise.map ...
 </code>
 </example>
 </summary>
 <param name="fail">Function to call if the input promise fail</param>
 <param name="pr">The input promise</param>
 <typeparam name="'T"></typeparam>
 <returns>A promise which is the result of the fail function</returns>
</member>
<member name="M:Promise.catch``1(Microsoft.FSharp.Core.FSharpFunc{System.Exception,``0},Fable.Core.JS.Promise{``0})">
 <summary>
 Handle an errored promise allowing you pass a return value.

 This version of <c>catch</c> expects a function returning just <c>'T</c>, as opposed to <c>Promise&lt;'T&gt;</c>. If you need to return <c>Promise&lt;'T&gt;</c>, use <c>catchBind</c>.
 <example>
 <code lang="fsharp">
 Promise.create (fun resolve reject ->
     reject (System.Exception "User not found")
 )
 |> Promise.catch (fun error ->
     // Log the error
     console.error error
     // Do something to recover from the error
     Error error.Message
 )
 |> Promise.map ...
 </code>
 </example>
 </summary>
 <param name="fail">Function to call if the input promise fail</param>
 <param name="pr">The input promise</param>
 <typeparam name="'T"></typeparam>
 <returns>A promise which result of the call of fail</returns>
</member>
<member name="M:Promise.tap``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Fable.Core.JS.Promise{``0})">
 <summary>
 This is an identity function, it calls the given function and return the promise value untouched.
 <example>
 <code lang="fsharp">
 fetchUser ()
 |> Promise.tap (fun user ->
     // Do something
     console.log "The user has been received"
 )
 |> Promise.map (fun user ->
     // user value is available here untouched
 )
 </code>
 </example>
 </summary>
 <param name="fn">A function to call after receiving the receiving of the input promise</param>
 <param name="a">The input promise</param>
 <typeparam name="'T"></typeparam>
 <returns>A promise of the same type as the input promise</returns>
</member>
<member name="M:Promise.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Fable.Core.JS.Promise{``0})">
 <summary>
 Call a function with the result of a promise and stop the promise chain.

 This is equivalent to <c>Promise.map ... |> ignore</c>
 <example>
 <code lang="fsharp">
 fetchUser ()
 |> Promise.iter (fun user ->
     console.log "User firstname is user.Firstname"
 ) // unit
 </code>
 </example>
 </summary>
 <param name="a">A function to apply to the result of the input promise</param>
 <param name="pr">The input promise</param>
 <typeparam name="'T"></typeparam>
</member>
<member name="M:Promise.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Fable.Core.JS.Promise{``0})">
 <summary>
 Map a value into another type, the result will be wrapped in a promise for you.
 <example>
 <code lang="fsharp">
 Promise.lift {| Firstname = "John" |}
 |> Promise.map (fun user ->
     user.Firstname
 ) // Returns a Promise&lt;string&gt; with the value "John"
 |> Promise.map ...
 </code>
 </example>
 </summary>
 <param name="a">A function to apply to the result of the input promise.</param>
 <param name="pr">The input promise</param>
 <typeparam name="'T1"></typeparam>
 <typeparam name="'T2"></typeparam>
 <returns>A promise after applying the mapping function</returns>
</member>
<member name="M:Promise.bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,Fable.Core.JS.Promise{``1}},Fable.Core.JS.Promise{``0})">
 <summary>
 Bind a value into a promise of a new type.
 <example>
 <code lang="fsharp">
 Promise.lift {| Firstname = "John" |}
 |> Promise.bind (fun user ->
     // Do something with user and returns a promise
     Promise.create (fun resolve reject ->
         resolve $"Hello, %s{user.Firstname}"
     )
 )
 |> Promise.map (fun message ->
     console.log message
     // Expected output: "Hello, John"
 )
 |> Promise.map ...
 </code>
 </example>
 </summary>
 <param name="a">
 A function that takes the value of type <c>T1</c> and transforms it into a promise of type <c>T2</c>.
 </param>
 <param name="pr">The input promise</param>
 <typeparam name="'T1"></typeparam>
 <typeparam name="'T2"></typeparam>
 <returns>A promise of the output type of the binder.</returns>
</member>
<member name="M:Promise.reject``1(System.Exception)">
 <summary>
 Creates promise (in rejected state) with supplied reason.
 <example>
 <code lang="fsharp">
 Promise.reject (Exception "User not found")
 |> Promise.map (fun _ ->
     // This promise is skipped
 )
 |> Promise.catch (fun error ->
     console.error $"An error ocurred: %s{error.Message}"
     // Expected output: "An error ocurred: User not found"
 )
 |> Promise.map ...
 </code>
 </example>
 </summary>
 <param name="reason">Reason to return</param>
 <typeparam name="'T"></typeparam>
 <returns>Return a promise in a rejected state</returns>
</member>
<member name="M:Promise.lift``1(``0)">
 <summary>
 Create a promise (in resolved state) with supplied value.
 <example>
 <code lang="fsharp">
 Promise.lift {| Firstname = "John" |}
 |> Promise.map (fun user ->
     console.log $"Hello, %s{user.Firstname}"
     // Expected output: "Hello, John"
 )
 |> Promise.map ...
 </code>
 </example>
 </summary>
 <param name="a">Value to return</param>
 <typeparam name="'T"></typeparam>
 <returns>Returns a promise returning the supplied value</returns>
</member>
<member name="M:Promise.sleep(System.Int32)">
 <summary>
 Create a promise which wait <c>X</c> ms before resolving.
 <example>
 <code lang="fsharp">
 // Do something
 doSomething ()
 // Sleep for 1 second
 |> Promise.sleep 1000
 // Do another thing
 |> Promise.map (fun _ ->
     doAnotherThing ()
 )
 |> Promise.map ...
 </code>
 </example>
 </summary>
 <param name="ms">Number of milliseconds to wait</param>
 <returns>A delayed promise</returns>
</member>
<member name="M:Promise.create``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.Unit}})">
 <summary>
 Create a promise from a function
 <example>
 <code lang="fsharp">
 let write (path: string) (content: string) =
     Promise.create (fun resolve reject ->
         Node.Api.fs.writeFile(path, content, (fun res ->
             match res with
             | Some res -> reject (res :?> System.Exception)
             | None -> resolve ()
         ))
     )
 </code>
 </example>
 </summary>
 <param name="f">
 Function used to create the promise, it receives two other function parameters:

 - <c>success</c> : called when the promise is resolved
 - <c>fail</c> : called when the promise is rejected
 </param>
 <typeparam name="'T">Return type of the promise</typeparam>
 <returns>
 The promise created by the function
 </returns>
</member>
</members>
</doc>
